In the web app, the charging duration input uses <input type="number"> which prevents users from typing letters or symbols.
However, it still allows negative numbers, producing negative costs (e.g., –2 hours → –$2.25).
During testing, we verified that the calculation logic needs backend validation to handle this gracefully.
The unit tests confirm that positive inputs calculate correctly and that negative or non-numeric inputs raise proper errors.
This prevents future bugs if the application later accepts external data or different form types.

%%writefile test_cost.py
import unittest

# Same constants as in the Flask app
KW = 7.5
PRICE_PER_KWH = 0.15

def calculate_cost(duration_hours):
    """
    Cost calculation for charging.
    Mirrors the logic in the Flask app: duration * 7.5 * 0.15,
    but adds validation so it fails gracefully for bad input.
    """
    if not isinstance(duration_hours, (int, float)):
        raise TypeError("Duration must be a number")
    if duration_hours < 0:
        raise ValueError("Duration cannot be negative")
    return duration_hours * KW * PRICE_PER_KWH

class TestCostFunction(unittest.TestCase):

    def test_positive_hours(self):
        # 2h → 2 * 7.5 * 0.15 = 2.25
        expected = 2 * KW * PRICE_PER_KWH
        self.assertAlmostEqual(calculate_cost(2), expected, places=2)

    def test_negative_hours_fails_gracefully(self):
        # Should not allow negative input
        with self.assertRaises(ValueError):
            calculate_cost(-3)

    def test_non_numeric_input_fails_gracefully(self):
        # Should fail (gracefully) for non-numeric input
        with self.assertRaises(TypeError):
            calculate_cost("abc")

if __name__ == "__main__":
    unittest.main()



!python3 -m unittest -v test_cost.py